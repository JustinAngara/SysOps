‚úÖ GOAL (Updated)

Inject either stealth.dll or memory_dumper.dll into a target process by PID or process name, using Java + JNI + native C++.

stealth.dll: Makes the target window invisible to screen recording tools.

memory_dumper.dll: Dumps a target process's memory to disk in hex or disassembly format.

üß± FILE STRUCTURE SUMMARY
/src/main/c++
‚îú‚îÄ‚îÄ CMakeLists.txt                 <-- Top-level builder for all DLLs
‚îú‚îÄ‚îÄ build_all.bat                 <-- Recompiles everything cleanly
‚îú‚îÄ‚îÄ target/native/                <-- All compiled DLLs output here

/src/main/c++/src/
‚îú‚îÄ‚îÄ systemlib/                    <-- JNI and injection wrapper logic
‚îÇ   ‚îú‚îÄ‚îÄ systemlib.cpp             <-- JNI bridge
‚îÇ   ‚îú‚îÄ‚îÄ action_handler.cpp/h      <-- JNI -> Injection delegation
‚îÇ   ‚îú‚îÄ‚îÄ process_inject.cpp/h      <-- Raw Windows DLL injection engine

‚îú‚îÄ‚îÄ stealth/                      <-- stealth.dll injected code
‚îÇ   ‚îî‚îÄ‚îÄ stealth.cpp

‚îú‚îÄ‚îÄ memory_dumper/                <-- memory_dumper.dll injected code
‚îÇ   ‚îî‚îÄ‚îÄ memory_dumper.cpp

üîç FILE-BY-FILE BREAKDOWN (Updated)
‚úÖ action_handler.h
void applyStealthByPid(DWORD pid);
void memoryDumpByProcessName(const std::string& processName);


Declares top-level C++ methods JNI will call.

‚úÖ action_handler.cpp
#include "process_inject.h"

void applyStealthByPid(DWORD pid) {
    injectDLLIntoPid(pid, "C:\\Path\\To\\stealth.dll");
}

void memoryDumpByProcessName(const std::string& proc) {
    DWORD pid = findPidByName(proc);
    if (pid) {
        injectDLLIntoPid(pid, "C:\\Path\\To\\memory_dumper.dll");
    }
}


Wraps DLL injection logic to be Java-callable.

‚úÖ process_inject.h
bool injectDLLIntoPid(DWORD pid, const std::string_view dllPath);
DWORD findPidByName(const std::string& name);


Handles Windows API interaction.

‚úÖ process_inject.cpp
bool injectDLLIntoPid(DWORD pid, const std::string_view dllPath) {
    // OpenProcess
    // Allocate memory for DLL path
    // Write DLL path into remote process
    // CreateRemoteThread with LoadLibraryA
}


Responsible for injecting any .dll into a process via PID.

‚úÖ systemlib.cpp
extern "C" JNIEXPORT void JNICALL Java_SystemLib_applyStealthByPid(JNIEnv*, jobject, jint pid) {
    applyStealthByPid(static_cast<DWORD>(pid));
}

extern "C" JNIEXPORT void JNICALL Java_SystemLib_memoryDumpByProcessName(JNIEnv* env, jobject, jstring name) {
    const char* raw = env->GetStringUTFChars(name, nullptr);
    memoryDumpByProcessName(raw);
    env->ReleaseStringUTFChars(name, raw);
}


JNI bridge. Java ‚Üí C++ ‚Üí Injector.

‚úÖ stealth.cpp
DWORD WINAPI StealthThread(LPVOID) {
    HWND hwnd = FindMainWindow(); // Your FindWindow logic here
    SetWindowDisplayAffinity(hwnd, 0x11);
    return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD reason, LPVOID) {
    if (reason == DLL_PROCESS_ATTACH) {
        CreateThread(nullptr, 0, StealthThread, nullptr, 0, nullptr);
    }
    return TRUE;
}

‚úÖ memory_dumper.cpp
DWORD WINAPI DumpThread(LPVOID) {
    HANDLE hProcess = GetCurrentProcess();
    dumpAllMemory(hProcess);  // Your hex-dump logic here
    return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD reason, LPVOID) {
    if (reason == DLL_PROCESS_ATTACH) {
        CreateThread(nullptr, 0, DumpThread, nullptr, 0, nullptr);
    }
    return TRUE;
}

üîó FLOW OF EXECUTION
‚úÖ Java Calls
SystemLib.applyStealthByPid(16388);
SystemLib.memoryDumpByProcessName("target.exe");

‚úÖ JNI C++ Bridges

Java_SystemLib_applyStealthByPid ‚Üí applyStealthByPid(pid)

Java_SystemLib_memoryDumpByProcessName ‚Üí memoryDumpByProcessName(name)

‚úÖ DLL Injected

injectDLLIntoPid(...)

Calls CreateRemoteThread(LoadLibraryA) on remote process

‚úÖ Inside Target Process

DllMain runs

Spawns background thread

Thread runs logic:

stealth.dll ‚Üí calls SetWindowDisplayAffinity(...)

memory_dumper.dll ‚Üí calls dumpAllMemory(...)

üõ†Ô∏è CMake & Build
üßæ Top-level CMakeLists.txt

Compiles each DLL separately:

cmake_minimum_required(VERSION 3.15)
project(SysOps)

add_subdirectory(src/systemlib)
add_subdirectory(src/stealth)
add_subdirectory(src/memory_dumper)


Each subfolder (e.g., src/stealth/CMakeLists.txt) contains its own:

add_library(stealth SHARED stealth.cpp)

add_custom_command(TARGET stealth POST_BUILD
  COMMAND ${CMAKE_COMMAND} -E make_directory "${CMAKE_SOURCE_DIR}/target/native"
  COMMAND ${CMAKE_COMMAND} -E copy_if_different "$<TARGET_FILE:stealth>" "${CMAKE_SOURCE_DIR}/target/native"
)


Same for memory_dumper.

‚öôÔ∏è To Build Everything
1. Run:
./build_all.bat

2. Output DLLs go to:
/src/main/c++/target/native/

3. Java loads them from there.
üß† Notes

‚úÖ Modular ‚Üí You can inject any.dll into any process.
‚úÖ Safe paths ‚Üí All paths absolute.
‚úÖ Admin ‚Üí Always run with elevated permissions.
‚úÖ Build isolation ‚Üí Each DLL is built in its own CMake module.
‚úÖ Easy injection ‚Üí injectDLLIntoPid(...) used universally.